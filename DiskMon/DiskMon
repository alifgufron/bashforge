#!/usr/bin/env bash

# MIT License
#
# Copyright (c) 2025 alifgufron
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
# ---

set -euo pipefail

# Ensure the shell environment is UTF-8 aware
export LANG=en_US.UTF-8
export LC_ALL=en_US.UTF-8

# --- Configuration ---
LOG_FILE="/var/log/harddisk_monitor.log"
DISK_USAGE_WARNING_THRESHOLD=90 # Percentage of disk usage to trigger a warning
REQUIRE_SMARTCTL=true # Set to 'false' to skip SMART checks if smartctl is not available

# --- Email Configuration ---
# REPORT_EMAIL_TO="your_email@example.com" # Replace with the recipient email address
# REPORT_EMAIL_FROM="monitor@yourdomain.com" # Replace with the sender email address
REPORT_EMAIL_TO="admin@example.net"
REPORT_EMAIL_FROM="disk-monitoring@$(hostname)"
EMAIL_SUBJECT_PREFIX="[Disk Monitoring]"

# --- SMART Attributes ---
# If these attributes have a RAW_VALUE > 0, a warning will be triggered.
CRITICAL_SMART_ATTRIBUTES=("Reallocated_Sector_Ct" "Current_Pending_Sector_Ct" "Offline_Uncorrectable" "UDMA_CRC_Error_Count")

# --- Helper Functions ---
log_message() {
    level="INFO"
    message="$1"
    if [ $# -gt 1 ]; then
        level="$1"
        message="$2"
    fi
    log_line="$(date '+%Y-%m-%d %H:%M:%S') - ${level} - ${message}"
    # Always write to the log file
    echo "$log_line" >> "$LOG_FILE"
    # Write to console only under specific conditions
    if [ "$IS_INTERACTIVE" -eq 1 ]; then
        # In interactive mode, print everything
        echo "$log_line"
    elif [ "$level" != "INFO" ]; then
        # In non-interactive (cron) mode, only print WARN and ERROR
        echo "$log_line"
    fi
}

# Check if a command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Detect the operating system
detect_os() {
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        echo "$NAME" | grep -qi "bsd" && echo "bsd" && return
    fi
    uname_out=$(uname -s)
    case "${uname_out}" in
        Linux*)
            echo "linux"
            ;;
        FreeBSD*)
            echo "bsd"
            ;;
        Darwin*)
            echo "bsd"
            ;;
        *)
            # Default to linux if we can't determine
            echo "linux"
            ;;
    esac
}

# Detect disks based on the operating system
detect_disks() {
    os_type="$1"
    disk_list=""
    case "${os_type}" in
        "bsd")
            # BSD systems: use smartctl --scan
            if command_exists smartctl; then
                # Use smartctl --scan as the primary method for BSD
                # This will find ada, da, nvme, and megaraid devices
                while IFS= read -r line; do
                    # Extract /dev/device from lines like '/dev/ada0 -d atacam # /dev/ada0, ATA device'
                    # or '/dev/mfi0 -d megaraid,0 # /dev/mfi0 [megaraid_disk_00], SCSI device'
                    # or '/dev/nvme0 -d nvme # /dev/nvme0, NVMe device'
                    if echo "$line" | grep -qE '^/dev/'; then
                        device_path=$(echo "$line" | awk '{print $1}')
                        device_type_arg=$(echo "$line" | sed -E 's/^[^[:space:]]+[[:space:]]+-d[[:space:]]+([^[:space:]]+).*$/\1/' || true)
                        if [ -n "$device_type_arg" ]; then
                            # Format as /dev/device,type_arg (e.g., /dev/mfi0,megaraid,0 or /dev/nvme0,nvme)
                            disk_list+="$device_path,$device_type_arg "
                        else
                            # For devices without -d argument (e.g., /dev/ada0 -d atacam -> treated as standard)
                            disk_list+="$device_path "
                        fi
                    fi
                done < <(smartctl --scan 2>/dev/null || true)
            fi
            ;;
        "linux")
            # Linux systems: use lsblk or smartctl --scan
            if command_exists lsblk; then
                disk_list=$(lsblk -r -o NAME,TYPE | grep -E "disk" | grep -v "loop\|ram\|sr" | awk '{print "\/dev\/" $1}')
            elif command_exists smartctl; then
                # Fallback to smartctl --scan
                disk_list=$(smartctl --scan | grep '^\/dev\/' | awk '{print $1}' | sort -u)
            fi
            ;;
        *)
            # Default to smartctl --scan for unknown systems
            disk_list=$(smartctl --scan | grep '^\/dev\/' | awk '{print $1}' | sort -u)
            ;;
    esac
    echo "$disk_list"
}

send_email_report() {
    # Sends the final report via sendmail.
    local subject="$1"
    local body="$2"
    local boundary="===BOUNDARY_$(date +%s)_$$==="
    local mailfile=$(mktemp)
    if [ -z "$mailfile" ] || [ ! -f "$mailfile" ]; then
        log_message "FATAL: Failed to create temporary file for email."
        return 1
    fi
    log_message "Sending email report with subject: $subject"
    # Build email headers and body
    {
        echo "From: ${REPORT_EMAIL_FROM}"
        echo "To: ${REPORT_EMAIL_TO}"
        echo "Subject: ${subject}"
        echo "MIME-Version: 1.0"
        echo "Content-Type: text/plain; charset=UTF-8"
        echo ""
        printf "%b" "$body"
    } > "$mailfile"

    # Send the email
    sendmail -t < "$mailfile"
    if [ $? -eq 0 ]; then
        log_message "Email report sent successfully to $REPORT_EMAIL_TO."
    else
        log_message "ERROR: Failed to send email report."
    fi

    # Cleanup
    rm -f "$mailfile"
}

# Helper function to run smartctl with a custom timeout (specifically for MegaRAID)
run_smartctl_with_timeout() {
    local device_path="$1"
    local smartctl_args="$2"
    local timeout_seconds=10
    local smart_output=""
    local tmp_file=$(mktemp) # Create temp file internally
    log_message "INFO" "Running smartctl for $device_path with custom timeout of $timeout_seconds seconds."
    log_message "DEBUG" "Executing: smartctl -a $smartctl_args \"$device_path\" > \"$tmp_file\" 2>&1 &"

    # Run smartctl in the background
    smartctl -a $smartctl_args "$device_path" > "$tmp_file" 2>&1 &
    local smartctl_pid=$!
    log_message "DEBUG" "smartctl PID: $smartctl_pid"

    # Wait for smartctl to finish, with a timeout
    local elapsed_time=0
    local interval=1 # Check every 1 second
    local smartctl_finished=0
    while [ "$elapsed_time" -lt "$timeout_seconds" ]; do
        if ! kill -0 "$smartctl_pid" 2>/dev/null; then
            # Process is no longer running
            log_message "DEBUG" "smartctl PID $smartctl_pid finished."
            smartctl_finished=1
            break
        fi
        sleep "$interval"
        elapsed_time=$((elapsed_time + interval))
        log_message "DEBUG" "Waiting for smartctl PID $smartctl_pid. Elapsed: $elapsed_time s."
    done

    if [ "$smartctl_finished" -eq 0 ]; then
        # smartctl is still running after timeout, kill it
        log_message "ERROR" "smartctl for $device_path (PID $smartctl_pid) timed out after $timeout_seconds seconds. Attempting to kill."
        kill -9 "$smartctl_pid" 2>/dev/null
        log_message "DEBUG" "Sent KILL -9 to PID $smartctl_pid."
        wait "$smartctl_pid" 2>/dev/null # Wait for it to be truly dead
        log_message "DEBUG" "Wait for PID $smartctl_pid completed after KILL -9."
        # Add error to report
        REPORT_BODY+="  - ❌ Disk $device_path: smartctl timed out and was force-killed after $timeout_seconds seconds (ERROR!)\n"
        ERROR_COUNT=$((ERROR_COUNT + 1))
        rm -f "$tmp_file" # Clean up temp file
        echo "" # Return empty string for SMART_OUTPUT
        return 1 # Indicate failure
    else
        # smartctl finished within the timeout
        wait "$smartctl_pid" # Get the actual exit code
        local smartctl_exit_code=$?
        log_message "DEBUG" "smartctl PID $smartctl_pid exited with code $smartctl_exit_code."
        if [ "$smartctl_exit_code" -ne 0 ]; then
            log_message "ERROR" "smartctl for $device_path failed with exit code $smartctl_exit_code."
            REPORT_BODY+="  - ❌ Disk $device_path: smartctl failed with exit code $smartctl_exit_code (ERROR!)\n"
            ERROR_COUNT=$((ERROR_COUNT + 1))
            rm -f "$tmp_file" # Clean up temp file
            echo "" # Return empty string for SMART_OUTPUT
            return 1 # Indicate failure
        fi
    fi

    # If successful, read the content and clean up
    smart_output=$(cat "$tmp_file")
    rm -f "$tmp_file" # Clean up temp file
    echo "$smart_output" # Return the SMART output
    return 0 # Indicate success
}

print_usage() {
    echo "Usage: $0 [OPTIONS]"
    echo "Monitor hard disk health and send email reports."
    echo ""
    echo "Options:"
    echo "  --mail-from <email>      Sender email address. Default: disk-monitoring@\$(hostname)"
    echo "  --mail-to <email>        Recipient email address. Default: admin@example.net"
    echo "  --smartctl <true|false>  Enable/disable SMART checks. Default: true"
    echo "  --disk-threshold <0-100> Disk usage percentage to trigger a warning. Default: 90"
    echo "  -h, --help               Display this help message."
    echo ""
    echo "Example:"
    echo "  $0 --mail-from monitor@example.com --mail-to alerts@example.com --smartctl false --disk-threshold 85"
}

# Helper function to robustly get a raw SMART attribute value by its name.
get_smart_attr_raw_value() {
    local smart_output="$1"
    local attr_name="$2"
    local raw_value="0"
    # Grep for the attribute name, case-insensitive, take the first match
    local attr_line=$(printf '%s\n' "$smart_output" | grep -i -m1 "$attr_name" || true)
    if [ -n "$attr_line" ]; then
        # Attempt to extract the raw value, which is usually the last numeric token on the line.
        raw_value=$(printf '%s\n' "$attr_line" | awk '{for(i=NF;i>=1;i--){ if ($i ~ /^[0-9]+$/){print $i; exit}}} ' || echo "0")
    fi
    # Default to 0 if not found or not a number
    echo "${raw_value:-0}"
}

# --- Main Logic ---
main() {
    # Detect if running in an interactive terminal
    IS_INTERACTIVE=0
    if [ -t 1 ]; then
        IS_INTERACTIVE=1
    fi

    # If no arguments are provided, display usage and exit.
    if [ "$#" -eq 0 ]; then
        log_message "INFO" "No arguments provided. Displaying usage and exiting."
        print_usage
        exit 1
    fi

    # --- Argument Parsing ---
    while [[ "$#" -gt 0 ]]; do
        case "$1" in
            --mail-from)
                REPORT_EMAIL_FROM="$2"
                shift
                ;;
            --mail-to)
                REPORT_EMAIL_TO="$2"
                shift
                ;;
            --smartctl)
                case "$(echo "$2" | tr '[:upper:]' '[:lower:]')" in
                    true|1|yes) REQUIRE_SMARTCTL=true ;;
                    false|0|no) REQUIRE_SMARTCTL=false ;;
                    *) log_message "ERROR" "Invalid value for --smartctl: $2. Using default." ;;
                esac
                shift
                ;;
            --disk-threshold)
                if [[ "$2" =~ ^[0-9]+$ ]] && (( "$2" >= 0 && "$2" <= 100 )); then
                    DISK_USAGE_WARNING_THRESHOLD="$2"
                else
                    log_message "ERROR" "Invalid value for --disk-threshold: $2. Must be a number between 0 and 100. Using default."
                fi
                shift
                ;;
            -h|--help)
                print_usage
                exit 0
                ;;
            *)
                log_message "WARN" "Unknown option: $1"
                ;;
        esac
        shift
    done

    # --- Argument Parsing ---
    SMARTCTL_AVAILABLE=true
    if ! command_exists smartctl; then
        if [ "$REQUIRE_SMARTCTL" = "true" ]; then
            log_message "FATAL" "smartctl is not available. Please install smartmontools."
            exit 1
        else
            log_message "WARN" "smartctl is not available. Skipping SMART checks."
            SMARTCTL_AVAILABLE=false
        fi
    fi

    if ! command_exists sendmail; then
        log_message "FATAL" "sendmail is not available. Please install a mail transfer agent."
        exit 1
    fi

    log_message "INFO" "Starting hard disk check..."

    # Detect operating system
    OS_TYPE=$(detect_os)
    log_message "INFO" "Detected OS type: $OS_TYPE"

    HOSTNAME=$(hostname)
    REPORT_BODY=""
    WARNING_COUNT=0
    ERROR_COUNT=0
    IGNORE_FILESYSTEMS="devfs tmpfs" # Space-separated list of filesystems to ignore from usage checks

    # 1. Add Filesystem Usage Report
    REPORT_BODY+="=== Filesystem Usage on $HOSTNAME ===\n"
    DF_OUTPUT=$(df -h)
    REPORT_BODY+="$DF_OUTPUT\n"

    # 1.1 Check Filesystem Usage for Warnings
    DISK_USAGE_WARNINGS=""
    # Use a process substitution to allow WARNING_COUNT to be updated in the main shell
    while read -r filesystem size used avail capacity mounted_on; do
        # Skip if filesystem is in the ignore list
        local skip_fs=0
        for ignored_fs in $IGNORE_FILESYSTEMS; do
            if [[ "$filesystem" == *"$ignored_fs"* ]] || [[ "$mounted_on" == *"$ignored_fs"* ]]; then
                skip_fs=1
                break
            fi
        done
        if [ "$skip_fs" -eq 1 ]; then
            continue
        fi
        # Remove '%' sign and convert to integer
        usage_percent=$(echo "$capacity" | sed 's/%//')
        # Skip if not a valid number (e.g., header or special entries)
        if ! [[ "$usage_percent" =~ ^[0-9]+$ ]]; then
            continue
        fi
        if [ "$usage_percent" -ge "$DISK_USAGE_WARNING_THRESHOLD" ]; then
            DISK_USAGE_WARNINGS+="  - ⚠️ Filesystem $mounted_on ($filesystem) is ${usage_percent}% full (WARNING!)\n"
            log_message "WARN" "Filesystem $mounted_on ($filesystem) is ${usage_percent}% full."
        fi
    done <<< "$(echo "$DF_OUTPUT" | tail -n +2)"

    if [ -n "$DISK_USAGE_WARNINGS" ]; then
        REPORT_BODY+="=== Filesystem Usage Warnings ===\n"
        REPORT_BODY+="$DISK_USAGE_WARNINGS"
        REPORT_BODY+="\n" # Blank line
        # Count warnings and add to total WARNING_COUNT
        WARNING_COUNT=$((WARNING_COUNT + $(echo "$DISK_USAGE_WARNINGS" | grep -c "⚠️")))
    fi

    # 2. Detect and Check SMART-capable disks
    log_message "INFO" "Scanning for disks using $OS_TYPE-specific methods..."
    REPORT_BODY+="=== SMART Health Status ===\n"

    # Detect disks based on OS
    DISK_LIST=$(detect_disks "$OS_TYPE")
    log_message "INFO" "Detected disks:\n$DISK_LIST"

    if [ -z "$DISK_LIST" ]; then
        REPORT_BODY+="No disks detected on this system.\n"
        log_message "INFO" "No disks detected."
    else
        # Check each disk
        for disk_entry in $DISK_LIST; do
            # Skip enclosure services devices
            if echo "$disk_entry" | grep -qE '^/dev/ses'; then
                log_message "INFO" "Skipping enclosure services device: $disk_entry"
                continue
            fi

            # --- 1. Parse device path and arguments (Corrected for SATA) ---
            device_path="$disk_entry"
            # smartctl_args is now only used for MegaRAID
            smartctl_args=""
            is_megaraid=0
            is_nvme=0
            # is_atacam_or_sat is now implicitly handled by the 'standard' command type
            command_type="standard" # Default

            if echo "$disk_entry" | grep -q ','; then
                device_path=$(echo "$disk_entry" | cut -d, -f1)
                type_arg_full=$(echo "$disk_entry" | cut -d, -f2-)
                if echo "$type_arg_full" | grep -q 'megaraid'; then
                    is_megaraid=1
                    smartctl_args="-d $type_arg_full"
                    command_type="megaraid"
                    log_message "DEBUG" "Parsed MegaRAID: $device_path with args $smartctl_args"
                elif echo "$type_arg_full" | grep -q 'nvme'; then
                    is_nvme=1
                    command_type="nvme"
                    log_message "DEBUG" "Parsed NVMe: $device_path"
                # Note: Removed the atacam/sat branch here.
                # The type_arg_full (like 'atacam' or 'sat') is still parsed
                # but command_type remains 'standard', which means no additional -d args
                # will be passed to the smartctl command itself.
                # The type_arg_full is primarily used during parsing to distinguish disk types.
                else
                    # Generic device type argument, treat as standard (e.g., for future types)
                    command_type="standard"
                    log_message "DEBUG" "Parsed Generic (Standard with type info): $device_path (type: $type_arg_full)"
                fi
            elif echo "$disk_entry" | grep -q 'nvme'; then
                 is_nvme=1
                 command_type="nvme"
                 log_message "DEBUG" "Parsed NVMe (no comma): $device_path"
            # Standard disk without specific args (likely direct SATA)
            else
                 command_type="standard"
                 log_message "DEBUG" "Parsed Standard Disk (no args): $device_path"
            fi

            # Skip if disk device does not exist
            if [ ! -e "$device_path" ]; then
                log_message "WARN" "Disk device '$device_path' (from entry '$disk_entry') does not exist, skipping."
                continue
            fi

            log_message "INFO" "Checking disk: $disk_entry (Command type: $command_type)"

            # --- 2. Execute smartctl based on determined type (Corrected SATA Command) ---
            SMART_OUTPUT=""
            TMP_SMART_FILE=$(mktemp)

            case "$command_type" in
                "megaraid")
                    # For MegaRAID, use the robust custom timeout function
                    SMART_OUTPUT=$(run_smartctl_with_timeout "$device_path" "$smartctl_args")
                    # run_smartctl_with_timeout handles its own errors and returns empty string on failure
                    # If it fails, SMART_OUTPUT will be empty, and subsequent checks will likely fail.
                    ;;
                "nvme")
                    # For NVMe, call smartctl directly without -d args (usually)
                    log_message "DEBUG" "Executing standard NVMe command: smartctl -a $device_path"
                    smartctl -a "$device_path" > "$TMP_SMART_FILE" 2>&1 || {
                        local exit_code=$?
                        log_message "ERROR" "smartctl command for NVMe $device_path failed (exit code $exit_code)."
                        REPORT_BODY+="  - ❌ Disk $device_path: smartctl command failed (exit code $exit_code) (ERROR!)\n"
                        ERROR_COUNT=$((ERROR_COUNT + 1))
                        rm -f "$TMP_SMART_FILE"
                        continue # Skip processing this disk further
                    }
                    SMART_OUTPUT=$(cat "$TMP_SMART_FILE")
                    rm -f "$TMP_SMART_FILE"
                    ;;
                "standard")
                    # For SATA/ATA/ATACAM/SAT without additional -d args
                    # The type information (atacam/sat) is used for parsing only, not for the command.
                    log_message "DEBUG" "Executing standard command (no extra -d): smartctl -a $device_path"
                    if [ "$OS_TYPE" = "bsd" ]; then
                        if command_exists perl; then
                            # Use perl alarm for BSD
                            PERLDB_OPTS="" PERL5OPT="" PERL5DB="" perl -e 'alarm(30); system("smartctl", "-a", @ARGV);' "$device_path" > "$TMP_SMART_FILE" 2>&1 || {
                                local perl_exit_code=$?
                                log_message "ERROR" "smartctl command for $device_path failed or timed out (perl exit code $perl_exit_code)."
                                REPORT_BODY+="  - ❌ Disk $device_path: smartctl command failed or timed out (exit code $perl_exit_code) (ERROR!)\n"
                                ERROR_COUNT=$((ERROR_COUNT + 1))
                                rm -f "$TMP_SMART_FILE"
                                continue # Skip processing this disk further
                            }
                        else
                            # Fallback if perl is not available - run without timeout but check exit code
                            smartctl -a "$device_path" > "$TMP_SMART_FILE" 2>&1 || {
                                local exit_code=$?
                                log_message "ERROR" "smartctl command for $device_path failed (exit code $exit_code)."
                                REPORT_BODY+="  - ❌ Disk $device_path: smartctl command failed (exit code $exit_code) (ERROR!)\n"
                                ERROR_COUNT=$((ERROR_COUNT + 1))
                                rm -f "$TMP_SMART_FILE"
                                continue # Skip processing this disk further
                            }
                        fi
                    else # Linux
                        # Use timeout for Linux
                        timeout 30 smartctl -a "$device_path" > "$TMP_SMART_FILE" 2>&1 || {
                            local timeout_exit_code=$?
                            log_message "ERROR" "smartctl command for $device_path failed or timed out (timeout exit code $timeout_exit_code)."
                            REPORT_BODY+="  - ❌ Disk $device_path: smartctl command failed or timed out (exit code $timeout_exit_code) (ERROR!)\n"
                            ERROR_COUNT=$((ERROR_COUNT + 1))
                            rm -f "$TMP_SMART_FILE"
                            continue # Skip processing this disk further
                        }
                    fi
                    SMART_OUTPUT=$(cat "$TMP_SMART_FILE")
                    rm -f "$TMP_SMART_FILE"
                    ;;
                *)
                    # Should not happen if logic above is correct
                    log_message "ERROR" "Unknown command type '$command_type' for disk $disk_entry. Skipping."
                    REPORT_BODY+="  - ❌ Disk $device_path: Unknown command type '$command_type' (ERROR!)\n"
                    ERROR_COUNT=$((ERROR_COUNT + 1))
                    continue
                    ;;
            esac

            # --- 3. Check if SMART is available ---
            # This section now relies on SMART_OUTPUT being populated correctly.
            # If previous command failed and skipped using 'continue', this part won't run for that disk.
            smart_available=0
            if [ "$is_nvme" -eq 1 ]; then
                if printf '%s\n' "$SMART_OUTPUT" | grep -qi "SMART overall-health self-assessment test result:"; then
                    smart_available=1
                fi
            else
                if printf '%s\n' "$SMART_OUTPUT" | grep -qi "SMART support is: Available"; then
                    smart_available=1
                elif printf '%s\n' "$SMART_OUTPUT" | grep -qi "SMART support is: Enabled"; then
                    smart_available=1
                fi
            fi

            if [ "$smart_available" -eq 0 ]; then
                 if [ -n "$SMART_OUTPUT" ] && printf '%s\n' "$SMART_OUTPUT" | grep -qi "SMART support is: Disabled"; then
                    WARNING_COUNT=$((WARNING_COUNT + 1))
                    REPORT_BODY+="\nSMART Status for $disk_entry: DISABLED\n"
                    log_message "WARN" "Disk $disk_entry has SMART disabled."
                 else
                    # This case now also catches if SMART_OUTPUT was empty due to a command failure
                    REPORT_BODY+="\nSMART Status for $disk_entry: UNAVAILABLE OR FAILED TO READ (Check logs)\n"
                    log_message "INFO" "SMART is not available, disabled, or failed to read on $disk_entry (Output might be empty due to command failure)."
                 fi
                 continue # Skip further processing for this disk if SMART is not available
            fi

            log_message "INFO" "Processing SMART data for $disk_entry..."

            # --- 4. Extract All Data Points (Robust Parsing) ---
            # Temporarily disable exit on error for parsing
            set +e

            # Common
            DEVICE_MODEL=$(printf '%s\n' "$SMART_OUTPUT" | grep -m1 -E "Device Model:|Model Number:" | cut -d: -f2- | xargs)
            SERIAL_NUMBER=$(printf '%s\n' "$SMART_OUTPUT" | grep -m1 "Serial Number:" | cut -d: -f2- | xargs)
            FIRMWARE_VERSION=$(printf '%s\n' "$SMART_OUTPUT" | grep -m1 "Firmware Version:" | cut -d: -f2- | xargs)
            USER_CAPACITY=$(printf '%s\n' "$SMART_OUTPUT" | grep -m1 -E "User Capacity:|Total NVM Capacity:" | cut -d: -f2- | xargs)
            HEALTH_STATUS=$(printf '%s\n' "$SMART_OUTPUT" | grep -m1 "SMART overall-health self-assessment test result:" | awk '{print $NF}')

            # Type-specific
            if [ "$is_nvme" -eq 1 ]; then
                DISK_TYPE="NVMe SSD"
                INTERFACE="PCIe NVMe"
                FORM_FACTOR=$(printf '%s\n' "$SMART_OUTPUT" | grep -m1 "Form Factor:" | cut -d: -f2- | xargs || true)
                FORM_FACTOR=${FORM_FACTOR:-"M.2/U.2"}
                NVME_VERSION=$(printf '%s\n' "$SMART_OUTPUT" | grep "NVMe Version:" | cut -d: -f2- | xargs || true)
                POWER_ON_HOURS=$(printf '%s\n' "$SMART_OUTPUT" | grep "Power On Hours:" | awk '{print $4}' | sed 's/,//g' || echo "0")
                POWER_CYCLE_COUNT=$(printf '%s\n' "$SMART_OUTPUT" | grep "Power Cycles:" | awk '{print $3}' || echo "0")
                TEMPERATURE=$(printf '%s\n' "$SMART_OUTPUT" | grep -m1 "Temperature:" | awk '{print $2}' || echo "0")
                PERCENTAGE_USED=$(printf '%s\n' "$SMART_OUTPUT" | grep "Percentage Used:" | awk '{print $3}' | sed 's/%//' || echo "0")
                DATA_UNITS_WRITTEN=$(printf '%s\n' "$SMART_OUTPUT" | grep "Data Units Written:" | awk '{print $4}' | sed 's/,//g' || echo "0")
                DATA_UNITS_READ=$(printf '%s\n' "$SMART_OUTPUT" | grep "Data Units Read:" | awk '{print $4}' | sed 's/,//g' || echo "0")
                UNSAFE_SHUTDOWNS=$(printf '%s\n' "$SMART_OUTPUT" | grep "Unsafe Shutdowns:" | awk '{print $3}' || echo "0")
                CONTROLLER_BUSY_TIME=$(printf '%s\n' "$SMART_OUTPUT" | grep "Controller Busy Time:" | awk '{print $4}' | sed 's/,//g' || echo "0")
                TOTAL_LBAS_WRITTEN=$((DATA_UNITS_WRITTEN * 1000)) # Convert Data Units (512k) to LBAs (512)
            else
                ROTATION_RATE=$(printf '%s\n' "$SMART_OUTPUT" | grep -m1 "Rotation Rate:" | cut -d: -f2- | xargs || true)
                FORM_FACTOR=$(printf '%s\n' "$SMART_OUTPUT" | grep -m1 "Form Factor:" | cut -d: -f2- | xargs || true)
                if [ -n "$ROTATION_RATE" ] && echo "$ROTATION_RATE" | grep -qi "Solid State"; then
                    DISK_TYPE="SATA SSD"; INTERFACE="SATA"
                else
                    DISK_TYPE="HDD"; INTERFACE="SATA/SAS"
                fi
                POWER_ON_HOURS=$(get_smart_attr_raw_value "$SMART_OUTPUT" "Power_On_Hours")
                POWER_CYCLE_COUNT=$(get_smart_attr_raw_value "$SMART_OUTPUT" "Power_Cycle_Count")
                TEMPERATURE=$(get_smart_attr_raw_value "$SMART_OUTPUT" "Temperature_Celsius")
                TOTAL_LBAS_WRITTEN=$(get_smart_attr_raw_value "$SMART_OUTPUT" "Total_LBAs_Written")
                LOAD_CYCLE_COUNT="" # Initialize for non-HDD types
            fi
            FORM_FACTOR=${FORM_FACTOR:-"Unknown"}

            # Re-enable exit on error
            set -e

            # --- 5. Build Report Section ---
            REPORT_BODY+="\n----------------------------------------------------\n"
            REPORT_BODY+="💽 Disk: $disk_entry (Type: $DISK_TYPE, Interface: $INTERFACE, FormFactor: $FORM_FACTOR)\n"
            REPORT_BODY+="----------------------------------------------------\n"
            [ -n "$DEVICE_MODEL" ] && REPORT_BODY+="Device Model: $DEVICE_MODEL\n"
            [ -n "$FIRMWARE_VERSION" ] && REPORT_BODY+="Firmware Version: $FIRMWARE_VERSION\n"
            [ -n "$SERIAL_NUMBER" ] && REPORT_BODY+="Serial Number: $SERIAL_NUMBER\n"
            [ -n "$USER_CAPACITY" ] && REPORT_BODY+="Capacity: $USER_CAPACITY\n"
            [ -n "$HEALTH_STATUS" ] && REPORT_BODY+="Health: $HEALTH_STATUS\n"
            [ -n "$TEMPERATURE" ] && [ "$TEMPERATURE" != "0" ] && REPORT_BODY+="Temperature: ${TEMPERATURE}°C\n"
            if [ -n "$POWER_ON_HOURS" ] && [ "$POWER_ON_HOURS" != "0" ]; then
                # Robust calculation for years
                set +e
                years=$(echo "${POWER_ON_HOURS:-0} / 8760" | bc -l 2>/dev/null | awk '{printf "%.1f", $1}' 2>/dev/null || echo "N/A")
                set -e
                if [ "$years" != "N/A" ] && [[ "$years" =~ ^[0-9.]+$ ]]; then
                    REPORT_BODY+="Power On Hours: $POWER_ON_HOURS (Approx. $years years of operation)\n"
                else
                    REPORT_BODY+="Power On Hours: $POWER_ON_HOURS (Calculation failed)\n"
                    log_message "WARN" "Failed to calculate years for disk $disk_entry (POH: $POWER_ON_HOURS)"
                fi
            fi
            if [ -n "$TOTAL_LBAS_WRITTEN" ]; then
                # Robust calculation for TBW
                set +e
                tbw=$(echo "(${TOTAL_LBAS_WRITTEN:-0} * 512) / 1000000000000" | bc -l 2>/dev/null | awk '{printf "%.2f", $1}' 2>/dev/null || echo "N/A")
                set -e
                if [ "$tbw" != "N/A" ] && [[ "$tbw" =~ ^[0-9.]+$ ]]; then
                    REPORT_BODY+="Total Data Written: $tbw TB\n"
                else
                    REPORT_BODY+="Total Data Written: $TOTAL_LBAS_WRITTEN (Calculation failed)\n"
                    log_message "WARN" "Failed to calculate TBW for disk $disk_entry (LBAs: $TOTAL_LBAS_WRITTEN)"
                fi
            fi
            if [ -n "$POWER_CYCLE_COUNT" ]; then
                PCC_STATUS="Normal"
                if [ "$POWER_CYCLE_COUNT" -gt 10000 ]; then PCC_STATUS="High"; fi
                REPORT_BODY+="Power Cycles: $POWER_CYCLE_COUNT ($PCC_STATUS)\n"
            fi
            REPORT_BODY+="\n----------------------------------------\n"

            if printf '%s\n' "$SMART_OUTPUT" | grep -qi "No Errors Logged"; then
                REPORT_BODY+="✅ No SMART errors logged\n"
            else
                REPORT_BODY+="⚠️ SMART Errors or Selftests present (see details)\n"
                WARNING_COUNT=$((WARNING_COUNT + 1))
            fi

            # NVMe/SSD Specific Attributes
            if [ "$DISK_TYPE" = "NVMe SSD" ]; then
                [ -n "$NVME_VERSION" ] && REPORT_BODY+="NVMe Version: $NVME_VERSION\n"
                [ -n "$PERCENTAGE_USED" ] && REPORT_BODY+="Percentage Used: ${PERCENTAGE_USED}%\n"
                [ -n "$PERCENTAGE_USED" ] && REPORT_BODY+="  -> NAND Health: $((100 - PERCENTAGE_USED))%\n"
                if [ -n "$DATA_UNITS_WRITTEN" ]; then
                    # Robust calculation for NVMe TBW
                    set +e
                    tbw=$(echo "($DATA_UNITS_WRITTEN * 512000) / 1000000000000" | bc -l 2>/dev/null | awk '{printf "%.2f", $1}' 2>/dev/null || echo "N/A")
                    set -e
                    if [ "$tbw" != "N/A" ] && [[ "$tbw" =~ ^[0-9.]+$ ]]; then
                        REPORT_BODY+="Data Units Written: $tbw TB\n"
                    else
                        REPORT_BODY+="Data Units Written: $DATA_UNITS_WRITTEN (Calculation failed)\n"
                        log_message "WARN" "Failed to calculate TBW for NVMe disk $disk_entry (DUW: $DATA_UNITS_WRITTEN)"
                    fi
                fi
                if [ -n "$DATA_UNITS_READ" ]; then
                    # Robust calculation for NVMe TBR
                    set +e
                    tbr=$(echo "($DATA_UNITS_READ * 512000) / 1000000000000" | bc -l 2>/dev/null | awk '{printf "%.2f", $1}' 2>/dev/null || echo "N/A")
                    set -e
                    if [ "$tbr" != "N/A" ] && [[ "$tbr" =~ ^[0-9.]+$ ]]; then
                        REPORT_BODY+="Data Units Read: $tbr TB\n"
                    else
                        REPORT_BODY+="Data Units Read: $DATA_UNITS_READ (Calculation failed)\n"
                        log_message "WARN" "Failed to calculate TBR for NVMe disk $disk_entry (DUR: $DATA_UNITS_READ)"
                    fi
                fi
                [ -n "$UNSAFE_SHUTDOWNS" ] && REPORT_BODY+="Unsafe Shutdowns: $UNSAFE_SHUTDOWNS\n"
                [ -n "$CONTROLLER_BUSY_TIME" ] && REPORT_BODY+="Controller Busy Time: ${CONTROLLER_BUSY_TIME} minutes\n"
            elif [ "$DISK_TYPE" = "SATA SSD" ]; then
                # Total_LBAs_Written is already handled above
                :
            elif [ "$DISK_TYPE" = "HDD" ]; then
                [ -n "$LOAD_CYCLE_COUNT" ] && REPORT_BODY+="Load Cycle Count: $LOAD_CYCLE_COUNT\n"
            fi

            if [ "$is_nvme" -eq 1 ]; then
                MEDIA_ERRORS=$(printf '%s\n' "$SMART_OUTPUT" | grep "Media and Data Integrity Errors:" | awk '{print $6}' || echo 0)
                if [ "$MEDIA_ERRORS" -gt 0 ]; then
                    WARNING_COUNT=$((WARNING_COUNT + 1))
                    REPORT_BODY+="  - ⚠️ Media and Data Integrity Errors: $MEDIA_ERRORS (WARNING!)\n"
                else
                    REPORT_BODY+="  - ✅ Media and Data Integrity Errors: $MEDIA_ERRORS (OK)\n"
                fi
                if [ -n "$PERCENTAGE_USED" ] && [ "$PERCENTAGE_USED" -ge 90 ]; then
                    WARNING_COUNT=$((WARNING_COUNT + 1))
                    REPORT_BODY+="  - ⚠️ Percentage Used: ${PERCENTAGE_USED}% (WARNING!)\n"
                else
                    REPORT_BODY+="  - ✅ Percentage Used: ${PERCENTAGE_USED:-0}% (OK)\n"
                fi
            else
                # Check critical attributes for non-NVMe disks
                for ATTR in "${CRITICAL_SMART_ATTRIBUTES[@]}"; do
                    ATTR_VALUE=$(get_smart_attr_raw_value "$SMART_OUTPUT" "$ATTR")
                    if [ "$ATTR_VALUE" -gt 0 ]; then
                        WARNING_COUNT=$((WARNING_COUNT + 1))
                        REPORT_BODY+="  - ⚠️ $ATTR: $ATTR_VALUE (WARNING!)\n"
                    else
                        REPORT_BODY+="  - ✅ $ATTR: $ATTR_VALUE (OK)\n"
                    fi
                done
            fi

            REPORT_BODY+="\n"
            log_message "INFO" "Completed processing $disk_entry"
        done
    fi

    # 3. Finalize and Send Report
    local subject_prefix_with_emoji=""
    local final_report_status=""
    REPORT_BODY+="\n=== Summary ===\n"

    if [ "$ERROR_COUNT" -gt 0 ]; then
        subject_prefix_with_emoji="❌ [Disk Monitoring]"
        final_report_status="CRITICAL ($ERROR_COUNT Errors)"
        REPORT_BODY+="CRITICAL: Found $ERROR_COUNT disk(s) with FAILED status and $WARNING_COUNT other warning(s).\n"
    elif [ "$WARNING_COUNT" -gt 0 ]; then
        subject_prefix_with_emoji="⚠️ [Disk Monitoring]"
        final_report_status="WARNING ($WARNING_COUNT Warnings)"
        REPORT_BODY+="WARNING: Found $WARNING_COUNT warning(s) on disks (e.g., high attribute values or SMART disabled).\n"
    else
        subject_prefix_with_emoji="✅ [Disk Monitoring]"
        final_report_status="OK"
        REPORT_BODY+="OK: All checked disks appear to be in good condition.\n"
    fi

    FINAL_SUBJECT="$subject_prefix_with_emoji on $HOSTNAME - $(date '+%Y-%m-%d') - $final_report_status"

    send_email_report "$FINAL_SUBJECT" "$REPORT_BODY"
    log_message "INFO" "Hard disk check completed."
}

# --- Script Execution ---
main "$@"
